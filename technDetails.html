<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale+1.0">
    <link rel="stylesheet" href="styles.css" />
    <link rel="stylesheet" href="techStyling.css" />
    <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/tokyo-night-dark.min.css">
    <title>Technical Details</title>
</head>

<body>
    <!--Header navigation and links-->
    <div class="navigation" id="header">
        <div class="sidebar">
            <ul class="nav">
                <li onclick=hideSidebar()><a href="#"><svg xmlns="http://www.w3.org/2000/svg" height="24px"
                            viewBox="0 -960 960 960" width="24px" fill="#D9D9D9">
                            <path
                                d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z" />
                        </svg></a></li>
                <li><a href="/whoWeAre.html">Who We Are</a></li>
                <li><a href="/Demonstrations.html">Demonstrations</a></li>
                <li><a href="/technDetails.html">Technical Details</a></li>
                <li><a href="/relatedLinks.html">Related Links</a></li>
            </ul>
        </div>
        <a href="https://ayihuang.github.io/">
            <img id="skatelligenceLogoImg" src="Skatelligence logo black.png" alt="Skatelligence full logo"
                style="width: 250px; height: 50px" />
        </a>
        <ul class="nav">
            <div class="hideOnMobile">
                <li><a href="/whoWeAre.html">Who We Are</a></li>
                <li><a href="/Demonstrations.html">Demonstrations</a></li>
                <li><a href="/technDetails.html">Technical Details</a></li>
                <li><a href="/relatedLinks.html">Related Links</a></li>
            </div>
            <div class="menu-button">
                <li onClick=showSidebar()><a href="#"><svg xmlns="http://www.w3.org/2000/svg" height="24px"
                            viewBox="0 -960 960 960" width="24px" fill="#000000">
                            <path d="M120-240v-80h720v80H120Zm0-200v-80h720v80H120Zm0-200v-80h720v80H120Z" />
                        </svg></a></li>
            </div>
        </ul>
    </div>
    <script>
        function showSidebar() {
            const sidebar = document.querySelector('.sidebar')
            sidebar.style.display = 'flex'
        }
        function hideSidebar() {
            const sidebar = document.querySelector('.sidebar')
            sidebar.style.display = 'none'
        }
    </script>
    <!--start of main page-->
    <div class="img-container"></div>
    <div class="padder"></div>
    <!--title with image-->
    <div class="tech-title">
        <img class="title-image" src="placeHolderCat.jpg" style="width: 300px; height: 225px;" />
        <div class="title-text">
            <h1>Technical Details</h1>
            <p>This page will provide an overview of the technical implementation of Skatelligence V0</p>
        </div>
    </div>
    <!--content begins-->
    <div class="hardware-schematic">
        <div>
            <h2>Hardware</h2>
            <p>Skatelligence V0 used the following hardware:</p>
            <ul>
                <li>1x ESP32 Development Board</li>
                <li>1x TCA9548A I2C Mux</li>
                <li>5x GY-521 IMUs</li>
                <li>1x SPI MicroSD Card Reader</li>
                <li>1x 32GB Micro SD Card</li>
                <li>8x JST XH2.54 4-Pin Connectors</li>
                <li>4x 3D Printed IMU Enclosure</li>
                <li>1x 3D Printed Main Enclosure</li>
                <li>6x Velcro Straps</li>
                <li>1x USB-C Battery Bank</li>
                <li>Miscelanious Wires</li>
                <li>Miscelanious Screws</li>
            </ul>
            <p>The connections can be seen in the following schematic</p>
        </div>
        <div class="img-caption">
            <img class="img-example" src="schematic.png" style="width: 600px; height: 511px">
            <p class="cpation">Electrical Schematic</p>
        </div>
    </div>
    <!--change of background colour in content-->
    <div class="blue">
        <h2>Data Collection</h2>
        <p>
            The ESP32 is connected using I2C to the I2C Mux, which is connected to the 5 IMUs. Each GY-521 IMU contains
            an MPU6050 chip which measures the linear acceleration and rotational velocity in all 3 directions
            (as well as the temperature, but we do not use this information). The ESP32 contains 2 physical cores. The first is
            dedicated to reading the acceleration and gyroscopic measurements from all
            5 IMUs 100 times per second, using the following C++ function.
        </p>
        <div class="code-block">
            <pre>
            <code> <!--was not recognizing arduino class, leave to default-->
void readMPU6050(int16_t* Ax, int16_t* Ay, int16_t* Az, int16_t* Gx, int16_t* Gy, int16_t* Gz) {
    Wire.beginTransmission(0x68); // MPU6050 address
    Wire.write(0x3B);             // Starting register for Accel Readings
    Wire.endTransmission(false);
    Wire.requestFrom(0x68, 14, true); // Request 14 registers

    *Ax = Wire.read() << 8 | Wire.read();
    *Ay = Wire.read() << 8 | Wire.read();
    *Az = Wire.read() << 8 | Wire.read();
    Wire.read(); Wire.read(); // Skip temperature
    *Gx = Wire.read() << 8 | Wire.read();
    *Gy = Wire.read() << 8 | Wire.read();
    *Gz = Wire.read() << 8 | Wire.read();
}
            </code>
            </pre>
        </div>
        <p>
            The raw values from the registers are stored in a binary file which contains 100 samples from 5 IMUs, each sample containing
            the 16 bit signed integer values of the x, y, and z directions for both linear acceleration and rotational velocity. These binary
            files are stored on the Micro SD card connected to the ESP32. The code that performs this is as follows
        </p>
        <div class="code-block">
            <pre>
            <code> <!--was not recognizing arduino class, leave to default-->
void readData(void * parameter) {
    TickType_t xLastWakeTime;
    const TickType_t xTimeIncrement = pdMS_TO_TICKS(POLL_INTERVAL_MS);
    
    File file;
    int pollCount = 0;
    int fileNumber = 0;
    
    // Initialize xLastWakeTime with the current time
    xLastWakeTime = xTaskGetTickCount();

    while (1) {
        // Wait until xTimeIncrement after xLastWakeTime
        vTaskDelayUntil(&xLastWakeTime, xTimeIncrement);

        if (!file){
            String fileName = "/" + String(fileNumber) + ".bin";
            file = SD.open(fileName, FILE_WRITE);
                if (!file) {
                    Serial.println("Failed to open file for writing");
                } else {
                    Serial.println("File opened successfully: " + fileName);
                }
        }
        
        for (int i = 0; i < 5; i++) {
            int16_t Ax, Ay, Az, Gx, Gy, Gz;
            tcaSelect(i);
            readMPU6050(&Ax, &Ay, &Az, &Gx, &Gy, &Gz);
            file.write((byte*)&Ax, sizeof(Ax));
            file.write((byte*)&Ay, sizeof(Ay));
            file.write((byte*)&Az, sizeof(Az));
            file.write((byte*)&Gx, sizeof(Gx));
            file.write((byte*)&Gy, sizeof(Gy));
            file.write((byte*)&Gz, sizeof(Gz));
        }

        pollCount++;

        // Check if this file is done
        if (pollCount >= POLLS_PER_FILE) {
            file.close();
            Serial.println("Finished writing to file: /" + String(fileNumber) + ".bin");
            lastCompletedFile = fileNumber; // Update the last completed file index
            fileNumber++;
            pollCount = 0;
        }
    }
}
            </code>
        </pre>
        </div>
        <p>
            After a file is done being written to, it is uploaded using http to a server running on a computer on the same network as the ESP32.
            If the internet connection temporarily drops out, it will continue writing files to the sd card locally and resume uploading once it 
            regains a strong connection. The code that performs this is:
        </p>
        <div class="code-block">
            <pre>
            <code> <!--was not recognizing arduino class, leave to default-->
void uploadData(void * parameter) {
    int lastUploadedFile = -1;
    while (1) {
        if (lastUploadedFile < lastCompletedFile) {
            String fileName = "/" + String(lastUploadedFile + 1) + ".bin";
            File fileToUpload = SD.open(fileName, FILE_READ);
            if (!fileToUpload) {
                Serial.println("Failed to open file for uploading");
            } else {
                Serial.println("Uploading file: " + fileName);
                if(WiFi.status() == WL_CONNECTED) {
                    HTTPClient http;
                    http.begin(serverName);
                    http.addHeader("Content-Type", "multipart/form-data; boundary=123456");

                    // Prepare the multipart/form-data body
                    String preData = "--123456\r\nContent-Disposition: form-data; name=\"file\"; filename=\"";
                    preData += String(fileName) + "\"\r\nContent-Type: application/octet-stream\r\n\r\n";
                    String postData = "\r\n--123456--\r\n";

                    // Read entire file into memory
                    String fileData;
                    while(fileToUpload.available()) {
                        fileData += (char)fileToUpload.read();
                    }

                    // Calculate content length
                    size_t totalSize = preData.length() + fileData.length() + postData.length();
                    http.addHeader("Content-Length", String(totalSize));

                    // Send the complete POST request
                    int httpResponseCode = http.POST(preData + fileData + postData);

                    if(httpResponseCode >= 200 && httpResponseCode <= 299) {
                        String response = http.getString();
                        Serial.print("Upload successful: HTTP Code ");
                        Serial.println(httpResponseCode);
                        Serial.println(response);
                        lastUploadedFile++; // Increment only on successful upload
                    } else {
                        Serial.print("Error on sending POST: HTTP Code ");
                        Serial.println(httpResponseCode);
                        if (httpResponseCode > 0) {
                            String response = http.getString();
                            Serial.println(response); // Print the error response
                        }
                    }
                    http.end();
                } else {
                    Serial.println("Error in WiFi connection");
                }
                fileToUpload.close();
            }
        }
        vTaskDelay(pdMS_TO_TICKS(10)); // Delay before trying again
    }
}
            </code>
            </pre>
        </div>
        <p>
            Once the server has recieved the files, it stores them locally to be used by the application
            and for data processing.
        </p>
    </div>
    <div>
        <h2>Data Processing</h2>
        <p>
            Before jumps can be identified in the data, it must first be processed. This involves two steps. 
            First, the raw data in the binary files are extracted, scaled to the appropariate units (Gs of acceleration and deg/s of rotational velocity),
            and the 30 individual streams of data are separated (5 sensors * 6 readings/sensor). This is done using the following code:
        </p>
        <div class="code-block">
            <pre>
            <code class="language-python"> <!--was not recognizing arduino class, leave to default-->
def read_file(file_path):
    # Scale the data and return that array
    if file_path:
        data = np.fromfile(file_path, dtype=np.int16)
        if data.size == 0:
            print(f"Warning: {file_path} is empty.")
            return None
        data = data.reshape((-1, SENSOR_COUNT * 6))
        scale_vector = np.tile(np.hstack([ACCEL_SCALE]*3 + [GYRO_SCALE]*3), SENSOR_COUNT)
        scaled_data = (data / 32768.0) * scale_vector
        return scaled_data
            </code>
            </pre>
        </div>
        <p>
            The data is then filtered using a low-pass 6th order Butterworth filter to remove noise from the data. This processed data is stored in
            the same format as the raw data to be used during the jump identification process. This is achieved with the following code:
        </p>
        <div class="code-block">
            <pre>
            <code class="language-python"> <!--was not recognizing arduino class, leave to default-->
def apply_low_pass_filter(data, cutoff, fs, order):
    nyq = 0.5 * fs  # Nyquist Frequency
    normal_cutoff = cutoff / nyq  # Normalize the frequency
    b, a = butter(order, normal_cutoff, btype='low', analog=False)  # Get filter coefficients
    filtered_data = filtfilt(b, a, data, axis=0)  # Apply filter
    return filtered_data
            </code>
            </pre>
        </div>
    </div>
    <div class="blue">
        <h2>Jump Classification</h2>
        <p>
            The jump classification is performed using two steps. First all jumps are identified, then the jumps are passed into an AI model to be classified.
            A sequence of IMU readings is considered a jump if and only if it meets the following criteria:
        </p>
        <ul>
            <li>Takeoff phase (Torso IMU sees vertical acceleration of at least 1.5Gs)</li>
            <li>Air phase (Torso IMU sees vertical acceleration of less than 0.5Gs, after takeoff phase)</li>
            <li>Landing phase (Torso IMU sees vertical acceleration of at least 1.5Gs, after air phase):</li>
            <li>The above three phases take between 0.2 seconds and 0.8 seconds to complete</li>
            <li>A numerical integration of the rotation around the torso's vertical access yields at least 180 degrees of rotation</li>
            <li>One of the skates sees a peak of at least 5Gs of vertical acceleration at some point in the jump</li>
        </ul>
        <p>
            If the above criteria is met, we define the jump to end 0.3 seconds after the landing phase and begin 1.5 seconds before that end.
            If a jump has been identified, the data is extracted and stored in a binary file.
        </p>
        <p>
            Data was then collected by mounting Skatelligence V0 to a skater and having them perform several of every type of jump. Due to time constraints, for Skatelligence V0,
            only single jumps were recorded, and they were only recorded for one skater. However, the AI model should generalize well to jumps with more rotations and various skaters,
            it just requires more high quality data. For data classification, we chose a RNN using LSTM units, as defined here:
        </p>
        <div class="code-block">
            <pre>
            <code class="language-python"> <!--was not recognizing arduino class, leave to default-->
class JumpClassifier(nn.Module):
def __init__(self):
    super(JumpClassifier, self).__init__()
    self.lstm = nn.LSTM(input_size=30, hidden_size=50, num_layers=4, batch_first=True)
    self.fc = nn.Linear(50, 6)  # 6 categories

def forward(self, x):
    x, _ = self.lstm(x)
    x = x[:, -1, :]  # Get last time step
    x = self.fc(x)
    return x
            </code>
            </pre>
        </div>
        <p>
            After training using the following, we were able to achieve a correct identification ~80% of the time:
            <div class="code-block">
                <pre>
                <code class="language-python"> <!--was not recognizing arduino class, leave to default-->
tensor_data = torch.Tensor(data)
tensor_labels = torch.LongTensor(labels)

X_train, X_val, y_train, y_val = train_test_split(tensor_data, tensor_labels, test_size=0.3, random_state=42)
train_dataset = TensorDataset(X_train, y_train)
val_dataset = TensorDataset(X_val, y_val)

train_loader = DataLoader(train_dataset, batch_size=16, shuffle=True)
val_loader = DataLoader(val_dataset, batch_size

criterion = nn.CrossEntropyLoss()
optimizer = torch.optim.Adam(model.parameters(), lr=0.001)

for epoch in range(200):  # Number of epochs
    for inputs, labels in train_loader:
        optimizer.zero_grad()
        outputs = model(inputs)
        loss = criterion(outputs, labels)
        loss.backward()
        optimizer.step()
    print(f'Epoch {epoch+1}, Loss: {loss.item()}')
                </code>
                </pre>
            </div>
        </p>
    </div>

    <!--scripts for code syntax highlighting-->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <!--footer navigation and links-->
    <div class="footer">
        <a href="https://ayihuang.github.io/">
            <img id="skatelligenceLogoImg" src="SkatelligenceFullLogoCropped.png" alt="Skatelligence full logo"
                style="width: 250px; height: 59px" />
        </a>
        <ul class="footNav">
            <li><a href="/whoWeAre.html">Who we Are</a></li>
            <li><a href="/Demonstrations.html">Demonstrations</a></li>
            <li><a href="/technDetails.html">Technical Details</a></li>
            <li><a href="/relatedLinks.html">Related Links</a></li>
        </ul>
    </div>
</body>

</html>